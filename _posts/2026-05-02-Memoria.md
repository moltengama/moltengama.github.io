---
title: "Memoria Winows"
date: 2026-02-04 00:00:00 +0800
categories: [maldev, c++,c]
tags: [maldev, c++,c,programming]
image:
  path: /assets/img/banners/14f8b1e4bc0d60b3651063dd6a4ddc71.jpg

---

**Pequeño recordatorio del manejo de memori en windows**

---

### Memoria virtual y paginación!

![Memoria]( /assets/img/20260121163615.png )
### Estado de la página

Las páginas que residen dentro del espacio de direcciones virtuales de un proceso pueden estar en uno de 3 estados:

1. **FREE** - La página no está comprometida ni reservada. <span style="background:#b1ffff">La página no es accesible para el proceso</span>. Está <span style="background:#b1ffff">disponible para ser reservado,</span> comprometido o simultáneamente reservado y comprometido. Intentar leer o escribir en una página gratuita puede generar una excepción de violación de acceso.
    
2. **Reservado** -<span style="background:#b1ffff"> La página ha sido reservada para uso futuro</span>. El rango de direcciones no puede ser utilizado por otras funciones de asignación. <span style="background:#b1ffff">La página no es accesible y no tiene almacenamiento físico asociado. </span>Está disponible para ser comprometido.
    
3. **Comprometido** - Los cargos de memoria se han asignado a partir del tamaño total de la RAM y los archivos de paginación en el disco. La página es accesible y el acceso está controlado por una de las constantes de protección de memoria. El sistema inicializa y carga cada página confirmada en la memoria física solo durante el primer intento de leer o escribir en esa página. Cuando finaliza el proceso, el sistema libera el almacenamiento de las páginas confirmadas.
### Opciones de protección de página

Una vez confirmadas las páginas, es necesario configurar su opción de protección. Se puede encontrar la lista de constantes de protección de memoria [aquí](https://learn.microsoft.com/en-us/windows/win32/memory/memory-protection-constants) pero a continuación se enumeran algunos ejemplos.

- `PAGE_NOACCESS`- Deshabilita todo acceso a la región comprometida de páginas. Un intento de leer, escribir o ejecutar la región comprometida dará como resultado una violación de acceso.
    
- `PAGE_EXECUTE_READWRITE`-<span style="background:#b1ffff"> Habilita lectura, escritura y ejecución</span>. 
> Se desaconseja encarecidamente su uso y generalmente es un IoC porque es poco común que la memoria sea escribible y ejecutable al mismo tiempo.
    
- `PAGE_READONLY`- Permite el acceso de solo lectura a la región comprometida de páginas. Un intento de escribir a la región comprometida da como resultado una violación de acceso.
### Protección de la memoria

- **Prevención de la ejecución de datos (DEP)** - <span style="background:#b1ffff">DEP es una función de protección de memoria a nivel de sistema</span> introducida en Windows XP SP2 y Windows Server 2003 SP1. <span style="background:#fff88f">Con DEP habilitado, el código no se puede ejecutar desde regiones de memoria que no estén marcadas explícitamente como ejecutables</span>, como aquellas protegidas con `PAGE_READONLY`.
    
- **Aleatorización del diseño del espacio de direcciones (ASLR)** - <span style="background:#fff88f">ASLR es una técnica de protección de memoria utilizada para prevenir la explotación de vulnerabilidades de corrupción de memoria</span>. ASLR <span style="background:#fff88f">organiza aleatoriamente las posiciones del espacio de direcciones de las áreas de datos clave de un proceso</span>, incluida la base del ejecutable y las posiciones de la pila, el montón y las bibliotecas### Espacio de memoria x86 vs x64

Al trabajar con procesos de Windows, es importante tener en cuenta si el proceso es x86 o x64. Los procesos x86 tienen un espacio de memoria más pequeño de 4 GB (`0xFFFFFFFF`) mientras que x64 tiene un espacio de memoria mucho mayor de 128 TB (`0xFFFFFFFFFFFFFFFF`)

### Ejemplo de asignación de memoria
``` C++
// Allocating a memory buffer of *100* bytes

// Method 1 - Using malloc()
PVOID pAddress = malloc(100);

// Method 2 - Using HeapAlloc()
PVOID pAddress = HeapAlloc(GetProcessHeap(), 0, 100);

// Method 3 - Using LocalAlloc()
PVOID pAddress = LocalAlloc(LPTR, 100);

```

el valor `pAddress` recibira como referencia la direccion base de bloque de memoria que fue asignado, usando este puintero se puede realizar varias acciones como:
- leer
- escribir
- ejecutar

`HeapAlloc` utiliza el `HEAP_ZERO_MEMORY` indicador que hace que la memoria asignada se inicialice a cero. L<span style="background:#fff88f">uego, la cadena se copia a la memoria asignada usando `memcpy`. </span>

<span style="background:#fff88f">El último parámetro en</span> `memcpy` es el número de bytes a copiar. A continuación, vuelva a verificar el búfer para verificar que los datos se escribieron correctamente.

```
memcpy([Destino], [Origen], #bytes)
```

![](/assets/img/20260121165225.png)

### Liberando memoria asignada
- Asignación con `malloc` requiere el uso de la `free` función.
    
- Asignación con `HeapAlloc` requiere el uso de la `HeapFree` función.
```c
	HeapFree(GetProcessHeap(), 0, pAddress);
```    
- Asignación con `LocalAlloc` requiere el uso de la `LocalFree` función.
